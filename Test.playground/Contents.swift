import UIKit

/*
//: # 1. (1 балл за каждый пункт)

//: ### 1.1 Что такое значимый (value) и  ссылочный(reference) тип? Приведите примеры.
когда мы создаем какой-нибудь объект, мы под него создаем ячейку в памяти. при значимом типе мы имеем дело непосредственно со значением этой ячейкм. при ссылочном - с адресом этой ячейки. то если если при ссылочном типе мы присваимем значение адреса этой ячейки, то при ее изменении будет меняться и то, чему мы это присвоили. при значимом типо если мы присвоили значение, а оно потом поменяется, то то, чему мы присвоили значение - не поменяется (не уверена, что то что написала можно адекватно понять)) сейчас на примере попытаюсь:*/
 
// значимый
var a = 3
var b = a
a = 5
// у b значение останется равно 3, а у а поменяется на 5

// ссылочный:
class  example {
    var a2 = 10
}
var x = example()
var z = x
x.a2 = 1
z.a2
// у z значение поменяется вместе с изменением свойства a2 класса example
 

/* ### 1.2 Чем отличается “struct“ от “class”?
от класса можно наследовать другие классы;
у класса ссылочный тип, а у структуры значимый
приведение типов
 
//: ### 1.3 Что такое Опционал(optional value)? Какие способы “unwrapping” для опционала вы знаете?
когда мы не знаем, будет ли у нас значение определенного указанного типа,или ничего там не будет (nil)
например год смерти писателя может быть типа int?, так как может принять значение года, или может принять параметр nil, если писатель жив
принудительное и косвенное
 
//: ### 1.4 Какие Коллекции(Collection types) вы знаете? Приведите примеры использования каждого из них(т.е. какую коллекцию для каких задач рациональнее использовать).
массивы, словари, множества
словари используются, когда для каждого значения из множества нужно хранить еще какие то доп данные. например когда у нас массив имен и нужного чтобы каждого был год рождения
массивы используем, когда нам важен порядок элементов в массиве. например важно, в каком имеено порядке поступали данные, которые добавляются в массив.
множества - когда не имеет значения порядок. например множество цветовых оттеннков

//: ### 1.5 Что такое замыкание(Closure)? Приведите примеры использования.
кусок кода, который есть необходимость часто ипользовать, передаем в качестве параметра и используем когда нужно
функция - частный случай замыкания.
еще плохо понимаю, в чем преимущество и когда лучше использовать замыкание, а когда функцию

//: ### 1.6 Что такое enum? Что такое raw и associated value?
тип данных, представляющий собой список возмодных значений
то есть мы сами описываем новый тип и перечисляем значения, которые он может принимать.
например, оценка работы может быть Плохой, Нормальной, Хорошей. мы создаем енам Оценка и перечисляем эти значения
ассоциированные это "характеристики" для значений в созданном типе данных. например создаем новый енам Настроение и каждому значению (плохое, веселое, грустное, замечательное) добавляем Int, чтобы оценить "силу" этого настроения например от 1 до 10
 явные значения - это когда мы сразу присваиваем какое нибудь значение нашим характеристикам. например в случае с оценкой можно было присвоить 1, 2,3 соответственно дляПлохой, Нормальной, Хорошей

//: ### 1.7 Как вы понимаете основные понятия/принципы ООП: Наследование, инкапсуляция, полиморфизм? Приведите примеры.
 наследование - когда от родительского класса все свойства переходят дочернему классу + плюс в дочернем появляются свойства, присущие только этому дочернему классу. например у нас есть класс одежда, содержащий общие свойства, присущие любой одежде:название, цвет, материал. мы создаем дочерний класс Брюки, в котором появляются свойства Обхват бедер, Длина и тд.
 инкапсуляция - это сокрытие данных от внешних объектов. то есть мы работаем с внешним интерфейсом, доступ к которому нам предоставлен
 полиморфизм - возможность взаимозаменяемости типов. то есть у нас переменная или константа одного типа может принимать разные формы в зависимости от конкретного объекта, на который она указывает

//: ### 1.8 Для чего существуют операторы "if" и "switch"? Чем они отличаются?
для проверки соответствия какому-либо условию
в иф мы выбираем между двумя условиями (если не писать вложенные ифы), а в свитч можем прописать сколько хотим.
насколько понимаю, нету каких то преимуществ использования того или иного оператора, в зависимости от задачи удобно использовать или тот, или другой


//: ### 1.9 Что такое Extension и Protocol. Для чего они предназначены? Какие принципы ООП они реализовывают?
расширения - возможность добавить новый функционал к уже существующему (но не изменить существующий, только добавить)
протоколы - описание требований к элементам внутри типа данных, грубо говоря набор правил и требований
 */





//: # 2. (2 балла за каждый пункт)
//:  2.1 Опишите enum который будет отражать общие состояния погоды(ясно, облачно, осадки и тд). Для тех состояний погоды, для которых возможно, опишите assosiated values с количеством осадков.

enum Weather {
    case rainy (level: Double)
    case sunny
    case cloudy
    case windy (speed: Double)
    case snowy (level: Double)
}


//:  2.2 Опишите функцию minValue, которая принимает 2 аргумента и возвращает меньшее из этих значений.

func minValue (_ first:Int, _ second:Int) -> Int {
    return first < second ? first : second
}

func minValue2 (_ first:Int, _ second:Int) -> Int {
    return min(first, second)
}


//:  2.3 Для следующего объекта типа String выведите все строки короче 10 символов, которые начинаются на "a" или "A" и все строки начинающиеся на b или "B"
let strings = ["adfkjsd", "Akdsfjkdfjldfjk", "bdkk", "kaf", " afurl", "ABBA", "ABBBBBBBBBBBBBBBBA", "no", "1234566dkjdksdjksd", "bbbbbbbbbbbbbbbbbbbb", "Ваc?"]
for element in strings {
        if (element.count<10) && (element.prefix(1)=="b" || element.prefix(1)=="B" || element.prefix(1)=="a" || element.prefix(1)=="A") {
            print(element)
    }
}


//:  2.4 Опишите функцию, которая принимает номер дня недели и возвращает название дня недели.

func dayOfWeek (_ number: Int) -> String {
    switch number {
    case 1:
        return "Monday"
    case 2:
        return "Tuesday"
    case 3:
        return "Wednesday"
    case 4:
        return "Thursday"
    case 5:
        return "Friday"
    case 6:
        return "Saturday"
    case 7:
        return "Sunday"
    default:
        return "The week hasn't such number"
    }
}

//:  2.5 Опишите функцию, которая получает время в качестве трех аргументов (часы, минуты, секунды) и возвращает время в качестве tuple (с тремя этими компонентами). С помощью typealias можете назвать исходящий тип по-своему.

//так и не сообразила, как сделать и что именно нужно сделать)

func time (_ hours:Int, _ min:Int, _ seconds:Int) -> (Int, Int, Int) {
    return (hours, min, seconds)
}
print (time (5, 3, 9))

//: 2.6 Опишите функцию, принимающую время в виде кортежа, описанного в предыдущем задании, конвертирует полученное время в секунды и возвращает значение Int(количество секунд)

func fromTimeToSecs (hours:Int, mins:Int, secs:Int) -> Int {
    return hours*60+mins*60+secs
}

//:  2.7 Опишите функцию обратную функции из предыдущего задания, принимающую 1 аргумент - количество секунд(например 1500) и конвертирует полученное время в формат кортежа (часы, минуты, секунды) из пункта 2.5
func fromSecToTime (seconds:Int) -> (hours:Int, mins:Int, secs:Int){
    var hours:Int
    var mins:Int
    var secs:Int
    if seconds/60 > 60 {
        hours = seconds/3600
        mins = (seconds%3600)/60
        secs = (seconds%3600)%60
    } else {
        hours = 0
        mins = seconds/60
        secs = seconds%60
    }
    return (hours, mins, secs)
}
fromSecToTime(seconds: 1600)

//:  2.8 Объявите переменную которая будет иметь тип Closure(замыкание), которое принимает аргументы Int и String и возвращает массив String. Присвойте ей реализацию, которая повторит в массиве строку n раз. Выполните эту функцию, передав ей число 7 и строку "test".

let closure = { (n:Int, string:String) -> [String] in
    var array = [string]
    for _ in 1...n {
        array.append(string)
    }
    return array
}
let result = closure (7, "test")

//:  2.9 Используя функцию `filter', получите массив только с городами с населением более 15 млн человек

struct City {
    let population: Int
    let country: String
    let name: String
}

let citiesArray = [City(population: 24_256_800, country: "Китай", name: "Шанхай"),
City(population: 23_500_000, country: "Пакистан", name: "Карачи" ),
City(population: 21_516_000, country: "Пекин", name: "Китай"),
City(population: 16_349_831, country: "Индия", name: "Дели"),
City(population: 16_060_303, country: "Нигерия", name: "Лагос"),
City(population: 15_200_000, country: "Китай", name: "Тяньцзинь"),
City(population: 14_160_467, country: "Турция", name: "Стамбул"),
City(population: 13_513_734, country: "Япония", name: "Токио"),
City(population: 13_080_500, country: "Китай", name: "Гуанчжоу"),
City(population: 12_442_373, country: "Индия", name: "Мумбаи"),
City(population: 12_197_596, country: "Россия", name: "москва"),
City(population: 11_895_893, country: "Бразилия", name: "Сан-Паулу"),
City(population: 10_467_400, country: "Китай", name: "Шэньчжэнь"),
City(population: 10_075_310, country: "Индонезия", name: "Джакарта"),
City(population: 10_052_000, country: "Пакистан", name: "Лахор"),]

var bigCities = citiesArray.filter{$0.population > 15_000_000}
print(bigCities)

//:# 3. (5 баллов за каждый пункт)
//: ### Представьте себе задачу по разработке приложения для домашней климатической техники. В рамках данной задачи вам необходимо выполнить следующее:
/*:
 3.1 Опишите базовый класс HomeSensor, который содержит несколько общих свойств для разных датчиков (например: датчик влажности, температуры, CO2):
 - значение измеряемого параметра данным датчиком value,
 - название измеряемого параметра,
 - целевое значение параметра - идальный показатель (targetValue),
 - точность в процентах (погрешность датчика),
 - id датчика
 - Опишите Void(Ничего не возвращающую) функцию "output" с пустым телом (т.е. что бы она ничего не делала) */

class HomeSensor {
    var value: Double
    var name: String
    var targetValue: Double
    var accuracy: Double = 1.0
    var id: String
    
    init(name:String, targetValue:Double, id:String, value:Double) {
        self.name = name
        self.targetValue = targetValue
        self.id = id
        self.value = value
    }
    
    func output() {
        
    }
}
 
 /*3.2 Опишите наследуемые классы для каждого типа датчиков (HumiditySensor, TemperatureSensor, COSensor)
 3.3 В дочерних классах переопределите функцию Output, что бы она выводила описание типа "Температура на датчике 13 равна 15ºС +/- 1ºС. Целевое значение - 19ºС" */

class HumiditySensor:HomeSensor {
    override func   output() {
        print("Влажность на датчике  \(id) = \(value)% +/- \(accuracy)%. Целевое значение - \(targetValue)%")
    }
    
}

class TemperatureSensor:HomeSensor {
    override func   output() {
        print("Температура на датчике  \(id) = \(value)ºС +/- \(accuracy)ºС. Целевое значение - \(targetValue)ºС")
    }
    
}

class COSensor:HomeSensor {
    override func   output() {
        print("Уровень угарного газа на датчике  \(id) = \(value)ppm +/- \(accuracy)ppm. Целевое значение - \(targetValue)ppm")
    }
    
}

/* 3.4 Опишите класс для комнаты(Room), который может содержать несколько сенсоров(HomeSensor) в одном свойстве c названием sensors. Так же Room должно содержать свойство - название комнаты.*/

class Room {
    var sensors: [HomeSensor] = []
    var name: String
    
    init(name: String) {
        self.name = name
    }
}

/* 3.5 Опишите класс Home, который может содержать несколько комнат(Room) в одном свойстве c названием rooms, а также опишите в нем функцию, которая выводит в консоль показания всех датчиков в каждой комнате, используя метод output
 */

class Home {
    var rooms: [Room] = []
    func viewSensors() {
        for room in rooms {
            for sensor in room.sensors {
                sensor.output()
            }
        }
    }
}

/*:
 Продемонстрируйте работу:
 - Создайте 1 экземпляр класса Home и  3 экземпляра Room (кухня, гостинная, спальня). Добавьте созданные экземпляры комнат в объект Home (в проперти rooms объекта Home)
 - Создайте и добавьте несколько экземпляров датчиков в каждую комнату
 - У объекта Home вызовите функцию, которая выводит в консоль показания всех датчиков в каждой комнате
 */
let myHome = Home()
let kitchen = Room(name: "Кухня")
let living = Room (name: "Гостиная")
let bedroom = Room (name: "Спальня")
myHome.rooms.append(kitchen)
myHome.rooms.append(living)
myHome.rooms.append(bedroom)

let sensor1 = HumiditySensor (name: "Датчик влажности в спальне", targetValue: 80.0, id: "349jfj45GJK", value: 75)
let sensor2 = TemperatureSensor (name: "Датчик температуры в спальне", targetValue: 20.0, id: "dfkh7648", value: 20)
let sensor3 = TemperatureSensor (name: "Датчик температуры в гостиной", targetValue: 22.0, id: "DGFkjkhk", value: 21)
let sensor4 = HumiditySensor (name: "Датчик влажности в гостиной", targetValue: 80.0, id: "jvdkf879768", value: 77)
let sensor5 = TemperatureSensor (name: "Датчик температуры на кухне", targetValue: 18.0, id: "346758745", value: 21)
let sensor6 = COSensor (name: "Датчик угарного газа на кухне", targetValue: 140.0, id: "skfkjbkjb7989798797", value: 140)

kitchen.sensors.append(sensor5)
kitchen.sensors.append(sensor6)
bedroom.sensors.append(sensor1)
bedroom.sensors.append(sensor2)
living.sensors.append(sensor3)
living.sensors.append(sensor4)

myHome.viewSensors()


//: Дополнительное задание:
/*:
 Для каждого датчика:
 - опишите дополнительное значение нижнего предела targetValueMin
 - опишите метод, устанавливающий targetValueMin и targetValueMax, предусмотрите валидацию введенного значения (что бы с точки зрения контекста каждого измерения не нарушалась логика)
 - в didSet проперти value предусмотрите сообщение в консоль в случае если новое значение больше, чем targetValue
 */
